<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <script src="./gpu-browser.min.js"></script>
        <style>
            canvas {
                background: #aaaaaa;
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <h1>GPU Tiling Example</h1>

        <script type='text/javascript'>
        
        function linearInterpolate(a, b, dist) {
            return a + ((b - a) * dist);
        }

        const width = 6000;
        const height = 6000;
	const antiAliasX = 1;
	const antiAliasY = 1;
        const colorMapSize = 10;

        // AXIS NORMALIZATION
        // Decide on the type and periodicity of your axes. Interpolate values for each pixel index.
        // In this case, I'm choosing a trigonemtric pattern function, whose period repeats from 0 -> 2*pi.
        // Also for simplicity, I'll interpolate from 0 -> 2*pi linearly.
        const xAxis = [];
        const yAxis = [];
        const twoPi = 2 * Math.PI;
        for (let it = 0; it < (width * antiAliasX); it++) {
            xAxis[it] = linearInterpolate(0, twoPi, it / (width * antiAliasX));
        }
        for (let it = 0; it < (height * antiAliasY); it++) {
            yAxis[it] = linearInterpolate(0, twoPi, it / (height * antiAliasY));
        }

        // PATTERN CREATION
        // Create a pattern "kernel" for the GPU that will 
        // produce a 2-D array of raw values that will be normalized to a color map eventually.
        const gpu = new GPU({
            mode: 'webgl2' // contrast with 'cpu'
            //mode: 'cpu'
        });
        const patternKernel = gpu.createKernel(function(xAxis, yAxis) {
	    const x = xAxis[this.thread.x];
	    const y = yAxis[this.thread.y];
            let real = 0;
            let imag = 0;
	    let newReal = 0;
	    let newImag = 0;
            for (let it = 0; it < this.constants.iterations; it++) {
               	newReal = real*real - imag*imag + Math.cos(x);
		newImag = 2*imag*real + Math.sin(y); 
		real = newReal;
		imag = newImag;
		if (real > 10000000) {
		    return it;
		}
            }
	    return this.constants.iterations;
        }, {
            constants: {
                iterations: 100
            },
	    graphical: false,
            output: [width * antiAliasX, height * antiAliasY]
        });
        let timerStart = Date.now();
        const rawValues = patternKernel(xAxis, yAxis);
        let timerEnd = Date.now();
        console.log('pattern generation time elapsed: ' + (timerEnd - timerStart) + ' ms');

        // CREATING THE COLOR MAP
        // Again, just using linear interpolation, this time between two color endpoints.
	// In a UI, provide a widget to travel through various color waypoints.
        const colorMap = [];
        const colorStart = [0, 0, 0]; // RGB 0->1
        const colorEnd = [1, 1, 1];   // RGB 0->1
        for (let it = 0; it < colorMapSize; it++) {
            const dist = it / colorMapSize;
            colorMap[it] = [
                linearInterpolate(colorStart[0], colorEnd[0], dist),
                linearInterpolate(colorStart[1], colorEnd[1], dist),
                linearInterpolate(colorStart[2], colorEnd[2], dist)
            ];
        }

	// NORMALIZE AND RESOLVE ANTI-ALIASING
	// Reduce the matrix by averaging extra pixels.
        // Find highest and lowest raw values.
        // We need these to normalize the domain of all raw values to our color map.
	// If this could be done in a kernel, then we wouldn't have to take the
	// results of the pattern function out of the GPU, which would save time.
        timerStart = Date.now();
        let lowest = Number.MAX_VALUE;
        let highest = Number.MIN_VALUE;
	const aaSize = antiAliasX * antiAliasY;
	const avgValues = [];
	for (let yIdx = 0; yIdx < height; yIdx++) {
	    avgValues[yIdx] = [];
	    for (let xIdx = 0; xIdx < width; xIdx++) {
		let sum = 0;
	        for (let xAA = 0; xAA < antiAliasX; xAA++) {
	    	    let x = xIdx * antiAliasX + xAA;
		    for (let yAA = 0; yAA < antiAliasY; yAA++) {
			let y = yIdx * antiAliasY + yAA; 
			let raw = rawValues[y][x];
			sum += raw;
			if (raw < lowest) {
		    	    lowest = raw;
			}
			if (raw > highest) {
		       	    highest = raw;
			}
		    }
		}
		const avg = sum / aaSize;
		avgValues[yIdx][xIdx] = avg;
	    }
	}
        const colorScale = (highest - lowest) / colorMapSize;
        timerEnd = Date.now();
        console.log('color normalization time elapsed: ' + (timerEnd - timerStart) + ' ms');

        // MAPPING
        const plotKernel = gpu.createKernel(function(avgValues, colorMap) {
            const val = avgValues[this.thread.y][this.thread.x];
            const colorIdx = Math.floor((val - this.constants.lowest) / this.constants.colorScale);
            this.color(
                colorMap[colorIdx][0],
                colorMap[colorIdx][1],
                colorMap[colorIdx][2]
            );
        }, {
            constants: {
                lowest: lowest,
                colorScale: colorScale
            },
            output: [width, height],
            graphical: true
        });

        timerStart = Date.now();
        plotKernel(avgValues, colorMap);
        timerEnd = Date.now();
        console.log('plot time elapsed: ' + (timerEnd - timerStart) + ' ms');
        const canvas = plotKernel.canvas;
	//canvas.width = width;
	//canvas.height = height;
        document.getElementsByTagName('body')[0].appendChild(canvas);

        // Improvements
        // - Proivde other periodicity axis functions to enable geometric, escape (i.e. akin to Mandelbrot), and other fun pattern functions
        // - Tie together with a really nice UI

        </script>
    </body>
</html>
